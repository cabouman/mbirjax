# -*- coding: utf-8 -*-
"""demo_1_shepp_logan.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1zG_H6CDjuQxeMRQHan3XEyX2YVKcSSNC

**MBIRJAX: Basic Demo**

See the [MBIRJAX documentation](https://mbirjax.readthedocs.io/en/latest/) for an overview and details.

This script demonstrates the basic MBIRJAX code by creating a 3D phantom inspired by Shepp-Logan, forward projecting it to create a sinogram, and then using MBIRJAX to perform a Model-Based, Multi-Granular Vectorized Coordinate Descent reconstruction.

For the demo, we create some synthetic data by first making a phantom, then forward projecting it to obtain a sinogram.

In a real application, you would load your sinogram as a numpy array and use numpy.transpose if needed so that it
has axes in the order (views, rows, channels).  For reference, assuming the rotation axis is vertical, then increasing the row index nominally moves down the rotation axis and increasing the channel index moves to the right as seen from the source.

Select a GPU as runtime type for best performance.
"""

# Commented out IPython magic to ensure Python compatibility.
# %pip install mbirjax

import numpy as np
import time
import pprint
import jax.numpy as jnp
import mbirjax

if __name__ == "__main__":

    """**Data generation:** For demo purposes, we create a phantom and then project it to create a sinogram.

    Note:  the sliders on the viewer won't work in notebook form.  For that you'll need to run the python code with an interactive matplotlib backend, typcially using the command line or a development environment like Spyder or Pycharm to invoke python.

    """
    """**Set the geometry parameters**"""

    # Choose the geometry type
    geometry_type = 'cone'

    # Set parameters for the problem size - you can vary these, but if you make num_det_rows very small relative to
    # channels, then the generated phantom may not have an interior.

    dataset_dir = '/depot/bouman/data/nsi_demo_data/demo_nsi_vert_no_metal_all_views'
    # dataset_dir = '/Users/gbuzzard/Documents/PyCharm Projects/Research/mbirjax_applications/nsi/demo_data/demo_data_nsi'

    downsample_factor = [1, 1]  # downsample factor of scan images along detector rows and detector columns.
    subsample_view_factor = 2  # view subsample factor.

    # #### recon parameters
    sharpness = 1.0
    # ###################### End of parameters

    print("\n*******************************************************",
            "\n************** NSI dataset preprocessing **************",
            "\n*******************************************************")
    time0 = time.time()
    sinogram, cone_beam_params, optional_params = \
        mbirjax.preprocess.nsi.compute_sino_and_params(dataset_dir,
                                                        downsample_factor=downsample_factor,
                                                        subsample_view_factor=subsample_view_factor)

    print("\n*******************************************************",
            "\n***************** Set up MBIRJAX model ****************",
            "\n*******************************************************")
    # ConeBeamModel constructor
    ct_model_for_full_recon = mbirjax.ConeBeamModel(**cone_beam_params)
    # Set additional geometry arguments
    ct_model_for_full_recon.set_params(**optional_params)
    # Set reconstruction parameter values
    ct_model_for_full_recon.set_params(sharpness=sharpness, verbose=1)

    angles = ct_model_for_full_recon.get_params('angles')
    source_detector_dist = ct_model_for_full_recon.get_params('source_detector_dist')
    source_iso_dist = ct_model_for_full_recon.get_params('source_iso_dist')


    # Initialize sinogram
    sinogram_shape = sinogram.shape
    # Take roughly the half of the sinogram and specify roughly half of the volume
    full_recon_shape = ct_model_for_full_recon.get_params('recon_shape')
    num_recon_slices = full_recon_shape[2]
    half_recons = []
    num_extra_rows = 2
    num_det_rows_half = sinogram_shape[1] // 2 + num_extra_rows

    # Initialize the model for reconstruction.
    sinogram_half_shape = (sinogram_shape[0], num_det_rows_half, sinogram_shape[2])

    # ConeBeamModel constructor
    ct_model_for_half_recon = mbirjax.ConeBeamModel(sinogram_half_shape, angles=angles,
                                                    source_detector_dist=source_detector_dist,
                                                    source_iso_dist=source_iso_dist)
    # Set additional geometry arguments
    ct_model_for_half_recon.set_params(**optional_params)
    # Set reconstruction parameter values
    ct_model_for_half_recon.set_params(sharpness=sharpness, verbose=1)

    recon_shape_half = ct_model_for_half_recon.get_params('recon_shape')
    num_recon_slices_half = recon_shape_half[2]

    for sinogram_half, sign in zip([sinogram[:, 0:num_det_rows_half], sinogram[:, -num_det_rows_half:]], [1, -1]):

        # View sinogram
        title = 'Half of sinogram \nUse the sliders to change the view or adjust the intensity range.'
        mbirjax.slice_viewer(sinogram_half, slice_axis=0, title=title, slice_label='View')

        delta_voxel, delta_det_row = ct_model_for_full_recon.get_params(['delta_voxel', 'delta_det_row'])
        recon_slice_offset = sign * (- delta_voxel * ((num_recon_slices-1)/2 - (num_recon_slices_half-1)/2))
        det_row_offset = sign * delta_det_row * ((sinogram_shape[1]-1)/2 - (num_det_rows_half-1)/2)

        ct_model_for_half_recon.set_params(recon_slice_offset=recon_slice_offset, det_row_offset=det_row_offset)

        # Print out model parameters
        ct_model_for_half_recon.print_params()

        """**Do the reconstruction and display the results.**"""

        # ##########################
        # Perform VCD reconstruction
        print('Starting recon')
        time0 = time.time()
        recon, recon_params = ct_model_for_half_recon.recon(sinogram_half)

        recon.block_until_ready()
        elapsed = time.time() - time0
        half_recons.append(recon)
        # ##########################
        mbirjax.slice_viewer(recon)

    num_overlap_slices = 2 * num_recon_slices_half - num_recon_slices
    num_non_overlap_slices = num_recon_slices - num_recon_slices_half
    recon = np.zeros(full_recon_shape)
    recon_top, recon_bottom = half_recons
    recon[:, :, :num_non_overlap_slices] = recon_top[:, :, :num_non_overlap_slices]
    recon[:, :, -num_non_overlap_slices:] = recon_bottom[:, :, -num_non_overlap_slices:]
    overlap_weights = (np.arange(num_overlap_slices) + 1.0) / (num_overlap_slices + 1.0)
    overlap_weights = overlap_weights.reshape((1, 1, -1))
    recon[:, :, num_non_overlap_slices:-num_non_overlap_slices] = (1 - overlap_weights) * recon_top[:, :, -num_overlap_slices:]
    recon[:, :, num_non_overlap_slices:-num_non_overlap_slices] += overlap_weights * recon_bottom[:, :, :num_overlap_slices]

    # Print parameters used in recon
    pprint.pprint(recon_params._asdict(), compact=True)

    mbirjax.get_memory_stats()
    print('Elapsed time for recon is {:.3f} seconds'.format(elapsed))

    # Display results
    title = 'Standard VCD recon (left) and residual with 2 halves stitched VCD Recon (right) \nThe residual is (stitched recon) - (standard recon).'
    mbirjax.slice_viewer(recon, title=title)

    """**Next:** Try changing some of the parameters and re-running or try [some of the other demos](https://mbirjax.readthedocs.io/en/latest/demos_and_faqs.html).  """